1.二叉树每个结点至多只有两棵子树(即二叉树中不存在度>2的结点)
2.相对于度为2的有序树,二叉树
  (1)可以为空
  (2)二叉树无论其孩子数是否为2,均需确定左右次序
     即二叉树的结点次序不是相对于另一结点而言,而是确定的
3.一个高度为h,且含有2^h-1个结点二叉树称为满二叉树
  (1)满二叉树所有叶子结点都在二叉树的最下一层,除叶子结点之外的每个结点度数均为2
  (2)可以对满二叉树按层序编号:
     若有双亲,双亲为[i/2] []为取整
     若有孩子,左孩子为2i,右孩子为2i+1
4.完全二叉树
  (1)有n个结点的完全二叉树 其1~n的结点编号与满二叉树一一对应
  (2)完全二叉树,就是满二叉树的缺损版,只缺损在最后面(最下最右)
5.二叉排序树
  (1)若左子树不空，则左子树上所有结点的值均小于它的根结点的值
  (2)若右子树不空，则右子树上所有结点的值均大于它的根结点的值
  (3)左、右子树也分别为二叉排序树
  (4)删除分支结点再插入,会大道至二叉排序树的重构
6.平衡二叉树
  (1)树上任一结点的左子树和右子树深度之差不超过1
  (2)就是说树不能翘脚翘得超过1层
  (3)相比完全二叉树,平衡二叉树可以缺少左孩子而有右孩子
7.完全二叉树和满二叉树采用顺序存储比较合适
  树中的结点序号可以唯一地反映结点之间的逻辑关系
8.对于一般的二叉树,为了让数组下标能反映二叉树中结点之间的逻辑关系
  添加一些并不存在的空结点,使之与完全二叉树上的结点相对照
9.以上的存储结构,数组需要从下标1开始,若数组从下标0开始存储,则无法根据
  i 2i等性质来计算出孩子结点等在数组中的位置
10.一般二叉树用链表存储
   数据域data 左指针域lchild 右指针域rchild
11.在含有n个结点的二叉链表中,有n+1个空链域
因为每一个节点有左右两个指针，n个节点共有2n个链域，
而n个节点只需用n-1个指针就可互连（因为连接n个点只需n-1条直线），
所以还剩下2n-(n-1)=n+1个
1.C?D?    在二叉排序树中插入结点时，一定插入在叶结点的位置，故先删除分支结点再插入，会导致二叉排序树的重构
2.A?D?    完全二叉树 第i个结点不一定有左孩子
3.B
4.B     
5.C
6.?       B存不存在还能通过奇偶怕判断 m=2n-1则m不能为偶数(服了)
7.C
8.C
9.C
10.A      完全二叉树砍掉最后一层是满二叉树
11.A?     C 完全二叉树(求结点最多那么叶子结点不在最后一层,求结点最少那么叶子结点在最后一层)
12.A      
13.C      D
14.D      C
15.C      希望n层结点最多,则n-1层须是满二叉树
16.A      B 算叶子结点 上一层少一个 下一层就多两个, 也可以上一层少一个下一层多一个,求最多有多少结点的时候,上-1下+1不会多出来叶子结点
17.B?     
18.A
19.C
20.D
21.D
22.A
1.完全二叉树高度h=[log2(n+1)]
(1)n=n0+1+n2=1+2n2-->n0==n2-->n=2n0;
h1=[log2(2n0+1)];
(2)n=n0+n2=n1+2n2+1-->n0=n2+1-->n=2n0-1;
h2=[log2(2n0-1+1)]=[log2(n0)]+1;
2.h=log2(n+1) n2=(n-1)/2 n0=(n+1)/2
3.495,248
4.1)m^(k-1)
  2)[(i+1)/m]
    假设i在第n行(n=1,2,3,…)
    前n-1行一共有[m^(n-1)-1]/(m-1)个结点
    则在第n行，结点i前有i-[m^(n-1)-1]/(m-1)-1个结点
    那么第n+1行，i的第1个子结点前有
    {i-[m^(n-1)-1]/(m-1)-1}*m个结点
    所以在i的第1个子结点前，一共有
    {i-[m^(n-1)-1]/(m-1)-1}*m+(m^n-1)/(m-1)个结点，化简得，有(i-1)*m+1个结点
    故i的第1个子结点j=(i-1)*m+2，证明完毕
    则i的双亲节点为[(i-2)/m]+1
  3)(i-1)*m+k+1 
  4)i!=2^h-1(h=logm(1-i+mi))
5.while(i!=j){         int的/是整除
  if(i>j)
    i=i/2;
  else
    j=j/2;
}